%include {
/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015-2017 Stian Valentin Svedenborg
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include "minicalc.h"
#include "ast.h"
#include <iostream>
#include <cassert>
#include <unordered_map>
#include <functional>
#include <memory>
#include <deque>

}

// Operator precendence
%nonassoc LOGIC_AND LOGIC_OR.
%nonassoc LOGIC_EQ LOGIC_NE LOGIC_LT LOGIC_GT LOGIC_LE LOGIC_GE.
%left PLUS MINUS.
%left DIV MUL MOD.
%right UNARY_MINUS LOGIC_NEG.
%left POW.
%nonassoc LPARENS RPARENS.

%extra_argument { MiniCalc *owner }

%syntax_error {
   owner->parse_error("Syntax error!");

}

%token_type  {MiniCalc::Token*}
%token_prefix {TOK_}
%token_destructor {
    (void) owner;
    delete $$;
}

%type expr       { AST::node* }
%destructor expr {
	delete $$;
}
%type arg_list   { std::deque<std::shared_ptr<AST::node>>* }
%destructor arg_list {
	delete $$;
}
%start_symbol start

start ::= expr(A). {
    owner->set_root(std::shared_ptr<AST::node>(A));
}

// Function calls:
arg_list(A) ::= expr(E).                        { A = new std::deque<std::shared_ptr<AST::node>>(); A->push_front(std::shared_ptr<AST::node>(E)); }
arg_list(A) ::= expr(E) COMMA arg_list(A_tail). { A = A_tail; A->push_front(std::shared_ptr<AST::node>(E)); }

expr(A) ::= IDENTIFIER(F) LPAREN arg_list(Args) RPAREN.  { A = AST::create_node(F->identifier, std::move(*Args)); }

// Binary Operators
expr(A) ::= expr(B) PLUS expr(C).    { A = AST::create_node("+", std::deque<std::shared_ptr<AST::node>>{std::shared_ptr<AST::node>(B), std::shared_ptr<AST::node>(C)}); }
expr(A) ::= expr(B) DIV expr(C).     { A = AST::create_node("/", std::deque<std::shared_ptr<AST::node>>{std::shared_ptr<AST::node>(B), std::shared_ptr<AST::node>(C)}); }
expr(A) ::= expr(B) MUL expr(C).     { A = AST::create_node("*", std::deque<std::shared_ptr<AST::node>>{std::shared_ptr<AST::node>(B), std::shared_ptr<AST::node>(C)}); }
expr(A) ::= expr(B) MINUS expr(C).   { A = AST::create_node("-", std::deque<std::shared_ptr<AST::node>>{std::shared_ptr<AST::node>(B), std::shared_ptr<AST::node>(C)}); }
expr(A) ::= expr(B) MOD expr(C).     { A = AST::create_node("%", std::deque<std::shared_ptr<AST::node>>{std::shared_ptr<AST::node>(B), std::shared_ptr<AST::node>(C)}); }
expr(A) ::= expr(B) POW expr(C).     { A = AST::create_node("**", std::deque<std::shared_ptr<AST::node>>{std::shared_ptr<AST::node>(B), std::shared_ptr<AST::node>(C)}); }
expr(A) ::= expr(B) LOGIC_EQ expr(C). { A = AST::create_node("==", std::deque<std::shared_ptr<AST::node>>{std::shared_ptr<AST::node>(B), std::shared_ptr<AST::node>(C)}); }
expr(A) ::= expr(B) LOGIC_NE expr(C). { A = AST::create_node("!=", std::deque<std::shared_ptr<AST::node>>{std::shared_ptr<AST::node>(B), std::shared_ptr<AST::node>(C)}); }
expr(A) ::= expr(B) LOGIC_LT expr(C). { A = AST::create_node("<", std::deque<std::shared_ptr<AST::node>>{std::shared_ptr<AST::node>(B), std::shared_ptr<AST::node>(C)}); }
expr(A) ::= expr(B) LOGIC_GT expr(C). { A = AST::create_node(">", std::deque<std::shared_ptr<AST::node>>{std::shared_ptr<AST::node>(B), std::shared_ptr<AST::node>(C)}); }
expr(A) ::= expr(B) LOGIC_LE expr(C). { A = AST::create_node("<=", std::deque<std::shared_ptr<AST::node>>{std::shared_ptr<AST::node>(B), std::shared_ptr<AST::node>(C)}); }
expr(A) ::= expr(B) LOGIC_GE expr(C). { A = AST::create_node(">=", std::deque<std::shared_ptr<AST::node>>{std::shared_ptr<AST::node>(B), std::shared_ptr<AST::node>(C)}); }
expr(A) ::= expr(B) LOGIC_AND expr(C). { A = AST::create_node("&&", std::deque<std::shared_ptr<AST::node>>{std::shared_ptr<AST::node>(B), std::shared_ptr<AST::node>(C)}); }
expr(A) ::= expr(B) LOGIC_OR expr(C).  { A = AST::create_node("||", std::deque<std::shared_ptr<AST::node>>{std::shared_ptr<AST::node>(B), std::shared_ptr<AST::node>(C)});  }

// Unary Operators
expr(A) ::= MINUS expr(B). [UNARY_MINUS] { A = AST::create_node("-Unary", std::deque<std::shared_ptr<AST::node>>{std::shared_ptr<AST::node>(B)}); }
expr(A) ::= LOGIC_NEG expr(B).         { A = AST::create_node("!", std::deque<std::shared_ptr<AST::node>>{std::shared_ptr<AST::node>(B)}); }

// Parenthesis:
expr(A) ::= LPAREN expr(B) RPAREN.  { A = B; }

// Variables
expr(A) ::= IDENTIFIER(F).  {
	// If the identifier is one of the named constants, parse it as a string constant.
	if (owner->get_constants() != nullptr && owner->get_constants()->find(F->identifier) != owner->get_constants()->end()) {
		A = AST::create_node(AST::value::string(F->identifier));
	}
	else {
		// Otherwise assume it is a variable
		A = AST::create_node(F->identifier, owner);
		owner->register_dependency(static_cast<AST::variable_node*>(A));  
	}
}

// Literals
expr(A) ::= INT(I). { A = AST::create_node(AST::value::integer(I->value)); }
expr(A) ::= TRUE. { A = AST::create_node(AST::value::boolean(true)); }
expr(A) ::= FALSE. { A = AST::create_node(AST::value::boolean(false)); }

